<===== WatchdogFS/src/alerts/local_script.rs =====>
// Local script execution
use std::process::Command;
use anyhow::Result;

/// Execute a local script (no arguments).  
/// Fails if the script returns a non-zero exit code.
pub fn execute_script(script_path: &str) -> Result<()> {
    let status = Command::new(script_path).status()?;
    if !status.success() {
        anyhow::bail!(
            "script {} exited with code {:?}",
            script_path,
            status.code()
        );
    }
    Ok(())
}
<===== WatchdogFS/src/alerts/mod.rs =====>
//! Alerting subsystem: syslog, HTTP webhook, or local script.

mod local_script;
mod syslog;
mod webhook;

pub use local_script::execute_script;
pub use syslog::send_syslog;
pub use webhook::send_webhook;

use crate::config::AlertsConfig;
use serde_json::json;
use std::path::Path;
use tracing::error;

/// Dispatch a file-change alert to all enabled channels.
pub fn dispatch(cfg: &AlertsConfig, path: &Path, old: String, new: String) {
    let path_str = path.display().to_string();
    let payload = json!({
        "path": path_str,
        "old": old,
        "new": new,
    })
    .to_string();

    // 1) Syslog
    if cfg.use_syslog {
        let msg = format!("Integrity change: {}", payload);
        if let Err(e) = send_syslog(&msg) {
            error!("syslog alert failed: {}", e);
        }
    }

    // 2) Webhook
    if let Some(url) = &cfg.webhook_url {
        if let Err(e) = send_webhook(url, &payload) {
            error!("webhook alert to {} failed: {}", url, e);
        }
    }

    // 3) Local script
    if let Some(script) = &cfg.script_path {
        if let Err(e) = execute_script(script) {
            error!("script alert `{}` failed: {}", script, e);
        }
    }
}

<===== WatchdogFS/src/alerts/syslog.rs =====>
// Syslog alerts
use anyhow::Result;
use syslog::{Facility, Formatter3164};

/// Send a one-line message to the local syslog.
pub fn send_syslog(message: &str) -> Result<()> {
    let formatter = Formatter3164 {
        facility: Facility::LOG_USER,
        hostname: None,
        process: "watchdogfs".into(),
        pid: 0,
    };

    let mut writer = syslog::unix(formatter)?;
    writer.info(message)?;
    Ok(())
}

<===== WatchdogFS/src/alerts/webhook.rs =====>
// HTTP webhook alerts

use anyhow::Result;
use reqwest::blocking::Client;

/// Send a JSON payload via HTTP POST to `url`.
pub fn send_webhook(url: &str, payload: &str) -> Result<()> {
    let client = Client::new();
    client
        .post(url)
        .header("Content-Type", "application/json")
        .body(payload.to_string())
        .send()?
        .error_for_status()?; // treat 4xx/5xx as errors
    Ok(())
}

<===== WatchdogFS/src/bin/daemon.rs =====>
use anyhow::{Context, Result};
use serde_yaml;
use std::{fs, path::PathBuf};
use watchdogfs::{
    config::Config,
    integrity::{Baseline, generate_map},
    logger, selfcheck, watcher,
};

fn main() -> Result<()> {
    logger::init().context("Logger init")?;
    tracing::info!("Starting WatchdogFS daemon");

    let config = load_config("/etc/watchdogfs/config.yaml")?;
    tracing::info!("Config loaded: {:?}", config);

    // Self-integrity check
    if let Some(sip) = &config.self_integrity_path {
        selfcheck::verify(sip)?;
    }

    let baseline = load_or_create_baseline(&config)?;
    tracing::info!("Baseline ready: {} entries", baseline.len());

    watcher::start(true)?;
    Ok(())
}

fn load_config(path: &str) -> Result<Config> {
    let s = fs::read_to_string(path).context("Reading daemon config")?;
    let c: Config = serde_yaml::from_str(&s).context("Parsing daemon config")?;
    Ok(c)
}

fn load_or_create_baseline(config: &Config) -> Result<Baseline> {
    let p = PathBuf::from("/var/lib/watchdogfs/baseline.json");
    if p.exists() {
        let s = fs::read_to_string(&p)?;
        let b: Baseline = serde_json::from_str(&s)?;
        Ok(b)
    } else {
        let b = generate_map(&config.watch_paths)?;
        let j = serde_json::to_string_pretty(&b)?;
        fs::write(&p, j)?;
        Ok(b)
    }
}

<===== WatchdogFS/src/cli/commands.rs =====>
// CLI commands logic
use clap::Subcommand;

#[derive(Subcommand)]
pub enum Commands {
    /// Initialize monitoring for files/directories
    Init {
        /// Path to create config at (default: ./config.yaml)
        #[arg(short, long, default_value = "config.yaml")]
        config: String,
    },

    /// Generate baseline checksums
    Baseline,

    /// Start monitoring process
    Start {
        #[arg(short, long)]
        daemon: bool,
    },
}

<===== WatchdogFS/src/cli/mod.rs =====>
// CLI parsing (clap)
mod commands;
pub use commands::*;

use anyhow::Result;
use clap::Parser;

#[derive(Parser)]
#[command(name = "watchdogfs")]
#[command(about = "Filesystem integrity monitor", version)]
pub struct Cli {
    /// Path to your config file
    #[arg(short, long, default_value = "config.yaml")]
    pub config: String,

    /// Optional path to a file containing the expected SHA256 of this binary
    #[arg(long)]
    pub self_integrity_path: Option<String>,

    #[command(subcommand)]
    pub command: Commands,
}

impl Cli {
    /// Helper to refer to the config file path
    pub fn config_path(&self) -> &str {
        &self.config
    }

    /// Helper to refer to the self-integrity path, if any
    pub fn self_integrity_path(&self) -> Option<&str> {
        self.self_integrity_path.as_deref()
    }
}

/// Wrapper to invoke clap
pub fn parse() -> Cli {
    Cli::parse()
}

pub fn init_command(path: &str) -> Result<()> {
    let p = std::path::Path::new(path);
    if p.exists() {
        anyhow::bail!("Config file {} already exists", path);
    }
    crate::config::write_default(p)?;
    println!("✅ Created new config at {}", path);
    Ok(())
}

<===== WatchdogFS/src/config/mod.rs =====>
// YAML configuration parsing (serde_yaml)
mod settings;
pub use settings::{Config, AlertsConfig};

use std::{fs, path::Path};
use anyhow::{Context, Result};
use serde_yaml;

pub fn write_default<P: AsRef<Path>>(path: P) -> Result<()> {
    let cfg: Config = Config::default();
    let yaml = serde_yaml::to_string(&cfg)
        .context("Failed to serialize default Config")?;
    fs::write(&path, yaml)
        .with_context(|| format!("Unable to write config to {:?}", path.as_ref()))?;
    println!("✅ Created new config at {:?}", path.as_ref());
    Ok(())
}

pub fn load<P: AsRef<Path>>(path: P) -> Result<Config> {
    let s = fs::read_to_string(&path)
        .with_context(|| format!("reading config file {:?}", path.as_ref()))?;
    let cfg: Config = serde_yaml::from_str(&s)
        .context("parsing YAML config")?;
    Ok(cfg)
}
<===== WatchdogFS/src/config/settings.rs =====>
// Config structures
use serde::Deserialize;
use serde::Serialize;

#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct Config {
    pub watch_paths: Vec<String>,
    pub ignore_patterns: Vec<String>,
    pub alerts: AlertsConfig,
    pub watcher: WatcherConfig,

    /// Optional path to a file containing the expected SHA256 of this binary.
    pub self_integrity_path: Option<String>,
}

impl Default for Config {
    fn default() -> Self {
        Config {
            watch_paths: Vec::new(),
            ignore_patterns: Vec::new(),
            alerts: AlertsConfig::default(),
            watcher: WatcherConfig::default(),
            self_integrity_path: None,
        }
    }
}


#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct WatcherConfig {
    pub mode: String,
    pub poll_interval: Option<u64>,
    pub debounce_ms: Option<u64>,
}

impl Default for WatcherConfig {
    fn default() -> Self {
        WatcherConfig {
            mode: "inotify".into(),
            poll_interval: Some(5),
            debounce_ms: Some(500),
        }
    }
}

#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct AlertsConfig {
    pub webhook_url: Option<String>,
    pub script_path: Option<String>,
    pub use_syslog: bool,
}

impl Default for AlertsConfig {
    fn default() -> Self {
        AlertsConfig {
            webhook_url: None,
            script_path: None,
            use_syslog: false,
        }
    }
}

<===== WatchdogFS/src/integrity/baseline.rs =====>
// Baseline generation & validation
use std::collections::HashMap;
use crate::integrity::calculate_checksum;
use anyhow::Result;

pub type Baseline = HashMap<String, String>;

pub fn generate(paths: &[String]) -> Result<Baseline> {
    let mut baseline = Baseline::new();
    for path in paths {
        let checksum = calculate_checksum(path)?;
        baseline.insert(path.clone(), checksum);
    }
    Ok(baseline)
}

<===== WatchdogFS/src/integrity/checksum.rs =====>
// SHA256 checksum logic
use sha2::{Sha256, Digest};
use std::fs;
use anyhow::Result;

pub fn calculate_checksum(path: &str) -> Result<String> {
    let data = fs::read(path)?;
    let mut hasher = Sha256::new();
    hasher.update(&data);
    Ok(format!("{:x}", hasher.finalize()))
}

<===== WatchdogFS/src/integrity/mod.rs =====>
// Integrity checking module

mod checksum;
mod baseline;

use anyhow::{Context, Result};
use serde_yaml;
use serde_json;
use std::{fs, path::Path};
use crate::config::Config;

pub use checksum::*;
pub use baseline::{generate as generate_map, Baseline};

pub fn init(_files: Vec<String>) -> Result<()> {
    // TODO: implement `watchdogfs init` logic (e.g. write config.yaml)
    Ok(())
}

pub fn generate_baseline() -> Result<Baseline> {
    // 1) Load & parse config.yaml
    let cfg_str = fs::read_to_string("config.yaml")
        .context("Failed to read `config.yaml` in current directory")?;
    let cfg: Config = serde_yaml::from_str(&cfg_str)
        .context("Failed to parse `config.yaml` as YAML")?;
    
    // 2) Generate the baseline map
    let baseline_map =  generate_map(&cfg.watch_paths)?;
    
    // 3) Serialize & write to baseline.json
    let out_path = Path::new("baseline.json");
    let json = serde_json::to_string_pretty(&baseline_map)
        .context("Failed to serialize baseline to JSON")?;
    fs::write(&out_path, json)
        .with_context(|| format!("Failed to write baseline to {}", out_path.display()))?;
    
    println!("✅ Baseline generated and saved to {}", out_path.display());
    Ok(baseline_map)
}

pub fn init_command(path: &str) -> Result<()> {
    let p = std::path::Path::new(path);
    if p.exists() {
        anyhow::bail!("Config file {} already exists", path);
    }
    crate::config::write_default(p)?;
    println!("✅ Created new config at {}", path);
    Ok(())
}
<===== WatchdogFS/src/logger/mod.rs =====>
// Structured logging setup (tracing)
use anyhow::Result;
use tracing_subscriber::EnvFilter;

pub fn init() -> Result<()> {
    tracing_subscriber::fmt()
        .json()
        .with_env_filter(EnvFilter::from_default_env())
        .init();
    Ok(())
}
<===== WatchdogFS/src/selfcheck/mod.rs =====>
use anyhow::{Context, Result};
use sha2::{Digest, Sha256};
use std::{env, fs};

/// Compute SHA256 over the current executable, compare to the contents of `path`.
/// The file must contain the hex-encoded expected SHA256.
pub fn verify(self_integrity_path: &str) -> Result<()> {
    // 1) Read expected hex digest
    let expected_hex = fs::read_to_string(self_integrity_path)
        .with_context(|| format!("reading self-integrity file `{}`", self_integrity_path))?
        .trim()
        .to_string();

    // 2) Locate our own binary
    let exe_path = env::current_exe().context("getting path to current executable")?;

    let data = fs::read(&exe_path)
        .with_context(|| format!("reading executable `{}`", exe_path.display()))?;

    // 3) Compute SHA256
    let mut hasher = Sha256::new();
    hasher.update(&data);
    let actual_hex = format!("{:x}", hasher.finalize());

    // 4) Compare
    if expected_hex != actual_hex {
        anyhow::bail!(
            "self-integrity failure: expected {} but got {}",
            expected_hex,
            actual_hex
        );
    }

    println!("✅ Self-integrity verified for {}", exe_path.display());
    Ok(())
}

<===== WatchdogFS/src/utils/mod.rs =====>
// Common utility functions
pub fn example_util() {
    println!("Example utility function");
}

<===== WatchdogFS/src/watcher/inotify.rs =====>
// Linux inotify implementation
use notify::{RecommendedWatcher, RecursiveMode, Watcher, Config, Result};
use std::path::Path;

pub fn watch<P: AsRef<Path>>(path: P) -> Result<()> {
    let mut watcher = RecommendedWatcher::new(
        |res| match res {
            Ok(event) => println!("File changed: {:?}", event),
            Err(e) => eprintln!("watch error: {:?}", e),
        },
        Config::default(), // Added missing argument
    )?;

    watcher.watch(path.as_ref(), RecursiveMode::Recursive)?;
    Ok(())
}

<===== WatchdogFS/src/watcher/mod.rs =====>
//! File monitoring abstraction.

use crate::alerts::dispatch;
use crate::config::Config;
use crate::integrity::{Baseline, calculate_checksum, generate_map};
use anyhow::{Result, bail};
use notify::Watcher;
use notify::{
    Config as NotifyConfig, Event, RecommendedWatcher, RecursiveMode, Result as NotifyResult,
};
use serde_yaml;
use std::{
    fs,
    path::PathBuf,
    thread::{self, park},
    time::{Duration, Instant},
};

/// Start the watcher. If `daemon == true`, blocks indefinitely.
pub fn start(daemon: bool) -> Result<()> {
    // 1. Load config.yaml
    let cfg_str = fs::read_to_string("config.yaml")?;
    let cfg: Config = serde_yaml::from_str(&cfg_str)?;

    // 2. Load baseline into a mutable map
    let baseline: Baseline = generate_map(&cfg.watch_paths)?;

    // 3. Dispatch to the chosen backend (pass ownership into each backend)
    match cfg.watcher.mode.as_str() {
        "inotify" => start_inotify(cfg.clone(), baseline, daemon)?,
        "poll" => start_polling(cfg.clone(), baseline, daemon)?,
        other => bail!("Unknown watcher mode: {}", other),
    }

    Ok(())
}

pub fn start_inotify(cfg: Config, baseline: Baseline, daemon: bool) -> Result<()> {
    // 1) Pre-calc debounce and copy the watch list
    let debounce = Duration::from_millis(cfg.watcher.debounce_ms.unwrap_or(500));
    let watch_paths = cfg.watch_paths.clone(); // so cfg can stay alive

    // 2) Clone only what the callback needs
    let callback_cfg = cfg.clone();
    let mut callback_baseline = baseline.clone();
    let mut last_seen = std::collections::HashMap::<String, Instant>::new();

    // 3) Build the watcher, capturing _only_ the clones above
    let mut watcher: RecommendedWatcher = RecommendedWatcher::new(
        move |res: NotifyResult<Event>| {
            on_event(
                res,
                &callback_cfg,
                &mut callback_baseline,
                &mut last_seen,
                debounce,
            )
        },
        NotifyConfig::default(),
    )?;

    // 4) Register each path (using the original cfg)
    for path in &watch_paths {
        watcher.watch(path.as_ref(), RecursiveMode::Recursive)?;
    }

    // 5) If daemon, block forever
    if daemon {
        park();
    }
    Ok(())
}

fn start_polling(cfg: Config, baseline: Baseline, daemon: bool) -> Result<()> {
    let interval = Duration::from_secs(cfg.watcher.poll_interval.unwrap_or(5));
    let debounce = Duration::from_millis(cfg.watcher.debounce_ms.unwrap_or(500));

    for watch_path in &cfg.watch_paths {
        let path = PathBuf::from(watch_path);
        let cfg_clone = cfg.clone();
        let mut baseline_clone = baseline.clone();

        thread::spawn(move || {
            let mut last_seen = Instant::now() - debounce;
            loop {
                thread::sleep(interval);
                if let Err(e) = on_poll(
                    &path,
                    &cfg_clone,
                    &mut baseline_clone,
                    &mut last_seen,
                    debounce,
                ) {
                    eprintln!("poll error: {:?}", e);
                }
            }
        });
    }

    if daemon {
        park();
    }
    Ok(())
}

fn on_event(
    res: NotifyResult<Event>,
    cfg: &Config,
    baseline: &mut Baseline,
    last_seen: &mut std::collections::HashMap<String, Instant>,
    debounce: Duration,
) {
    if let Ok(event) = res {
        for path_buf in event.paths {
            let path_str = path_buf.to_string_lossy().into_owned();
            let now = Instant::now();
            let prev = last_seen
                .get(&path_str)
                .cloned()
                .unwrap_or_else(|| now - debounce * 2);
            if now.duration_since(prev) < debounce {
                continue; // skip rapid duplicates
            }
            last_seen.insert(path_str.clone(), now);

            if let Ok(new_sum) = calculate_checksum(&path_str) {
                // Insert returns the old checksum if present
                let old_sum_opt = baseline.insert(path_str.clone(), new_sum.clone());
                if let Some(old_sum) = old_sum_opt {
                    if old_sum != new_sum {
                        dispatch(&cfg.alerts, &path_buf, old_sum, new_sum.clone());
                    }
                }
            }
        }
    }
}

fn on_poll(
    path: &PathBuf,
    cfg: &Config,
    baseline: &mut Baseline,
    last_seen: &mut Instant,
    debounce: Duration,
) -> Result<()> {
    let now = Instant::now();
    if now.duration_since(*last_seen) < debounce {
        return Ok(()); // still in debounce window
    }

    let path_str = path.to_string_lossy();
    let new_sum = calculate_checksum(&path_str)?;
    let old_sum_opt = baseline.get(&*path_str).cloned();
    if let Some(old_sum) = old_sum_opt {
        if old_sum != new_sum {
            dispatch(&cfg.alerts, path, old_sum, new_sum.clone());
            baseline.insert(path_str.to_string(), new_sum.clone());
            *last_seen = now;
        }
    }
    Ok(())
}

<===== WatchdogFS/src/watcher/polling.rs =====>
// Polling fallback implementation
use std::{thread, time};
use std::fs::metadata;
use anyhow::Result;

pub fn poll(path: &str, interval: u64) -> Result<()> {
    loop {
        let meta = metadata(path)?;
        println!("Checked {}: {:?}", path, meta.modified()?);
        thread::sleep(time::Duration::from_secs(interval));
    }
}


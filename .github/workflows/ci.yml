name: CI / Release

# 1) Run tests on pushes to master or PRs
# 2) Create a GitHub Release (and upload artifacts) when you push a tag like "v1.2.3"
on:
  push:
    branches:
      - master
    tags:
      - 'v*'           # every tag prefixed with "v", e.g. "v1.0.0"
  pull_request:

env:
  # Make sure we cache ~/.cargo so that both registry+git caches are shared
  CARGO_HOME: ~/.cargo
  RUSTUP_HOME:  ~/.rustup

jobs:
  # ────────────────────────────────────────────────────────────────────────────
  # 1) CI job: run clippy + tests on master/PR
  # ────────────────────────────────────────────────────────────────────────────
  test-and-lint:
    if: github.event_name != 'push' || github.ref_type != 'tag'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Install Rust toolchain
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          profile: minimal
          components: rustfmt, clippy
          override: true

      # Cache the registry and index so that `cargo fetch` is fast
      - name: Cache cargo registry
        uses: actions/cache@v3
        with:
          path: ~/.cargo/registry
          key: ${{ runner.os }}-cargo-registry-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-registry-

      - name: Cache cargo-git index
        uses: actions/cache@v3
        with:
          path: ~/.cargo/git
          key: ${{ runner.os }}-cargo-git-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-git-

      # Lint with clippy, fail on warnings
      - name: Run clippy
        run: cargo clippy --all -- -D warnings

      # Run all tests
      - name: Run tests
        run: cargo test --all

  # ────────────────────────────────────────────────────────────────────────────
  # 2) Release build: only runs when you push a tag (vX.Y.Z)
  #    a) Builds for multiple targets in parallel (using `cross`)
  #    b) Uploads each compiled binary to the Release as an “asset”
  # ────────────────────────────────────────────────────────────────────────────
  release:
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')
    needs: test-and-lint       # ensure tests pass before building release
    runs-on: ubuntu-latest

    strategy:
      matrix:
        # List of targets you want to build. You can add/remove as needed.
        target:
          - x86_64-unknown-linux-musl
          - x86_64-unknown-linux-gnu
          - x86_64-pc-windows-gnu
          - x86_64-apple-darwin

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Install Rust toolchain
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          profile: minimal
          override: true

      # Install cross once (cached by Cargo)
      - name: Install cross
        run: cargo install cross

      # Ensure the target is added (for targets that don't need cross, you could skip this)
      - name: Add Rust target (if needed)
        run: rustup target add ${{ matrix.target }} || true

      # Build with `cross` so that each matrix entry is built in parallel
      - name: Build release for ${{ matrix.target }}
        run: |
          # If you want to compile with features or a workspace:
          # cross build --release --target ${{ matrix.target }} --all
          cross build --release --target ${{ matrix.target }}
        env:
          # Tell cross to reuse the host's Docker credentials if building many Linux targets
          CROSS_WAIT: "10"

      # Collect the built binary (.exe on Windows)
      - name: Package artifact
        run: |
          # For Windows, cross will put binaries in:
          # target/x86_64-pc-windows-gnu/release/*.exe
          #
          # For Linux/musl and linux-gnu:
          # target/$TARGET/release/<your_binary_name>
          #
          # For macOS: target/x86_64-apple-darwin/release/<your_binary_name>
          BINARY_NAME="watchdogfs"             # <-- Replace with your actual binary name
          TARGET_DIR="target/${{ matrix.target }}/release"
          mkdir -p artifacts/${{ matrix.target }}
          
          if [[ "${{ matrix.target }}" == *"windows-gnu" ]]; then
            cp "${TARGET_DIR}/${BINARY_NAME}.exe" artifacts/${{ matrix.target }}/${BINARY_NAME}-${{ matrix.target }}.exe
          else
            cp "${TARGET_DIR}/${BINARY_NAME}" artifacts/${{ matrix.target }}/${BINARY_NAME}-${{ matrix.target }}
            chmod +x artifacts/${{ matrix.target }}/${BINARY_NAME}-${{ matrix.target }}
          fi

      - name: Upload built artifact
        uses: actions/upload-artifact@v3
        with:
          name: my-cli-${{ matrix.target }}
          path: artifacts/${{ matrix.target }}/

  # ────────────────────────────────────────────────────────────────────────────
  # 3) Once all matrix builds complete, create a GitHub Release & attach binaries
  # ────────────────────────────────────────────────────────────────────────────
  publish-to-github-release:
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')
    needs: release
    runs-on: ubuntu-latest

    steps:
      - name: Download all artifacts from release job
        uses: actions/download-artifact@v3
        with:
          # Download everything uploaded by `release` under any name
          path: ./all_artifacts

      # Create a GitHub Release (if it doesn't exist) or update the existing one
      - name: Create GitHub Release
        id: create_release
        uses: actions/create-release@v1
        with:
          tag_name: ${{ github.ref_name }}       # e.g. "v1.2.3"
          release_name: Release ${{ github.ref_name }}
          draft: false
          prerelease: false

      # Upload each target‐specific binary as a separate asset
      - name: Upload target binaries to Release
        uses: actions/upload-release-asset@v1
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ./all_artifacts
          asset_name: ''   # We will override `asset_name` dynamically per file below
          asset_content_type: application/octet-stream
        # Unfortunately upload-release-asset@v1 does not support globbing,
        # so we must loop over files and call this step multiple times.
      - name: Loop & attach each binary
        shell: bash
        run: |
          set -euo pipefail
          RELEASE_UPLOAD_URL="${{ steps.create_release.outputs.upload_url }}"

          # For each target folder in all_artifacts/, upload the file inside it
          for dir in all_artifacts/*/; do
            for file in "$dir"*; do
              fname=$(basename "$file")
              echo "Uploading $fname to GitHub Release..."
              curl \
                -X POST \
                -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                -H "Content-Type: application/octet-stream" \
                --data-binary @"$file" \
                "${RELEASE_UPLOAD_URL}?name=${fname}"
            done
          done

      - name: Release published
        run: echo "Release ${{ github.ref_name }} published with artifacts!"

